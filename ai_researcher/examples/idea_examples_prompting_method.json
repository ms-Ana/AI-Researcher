{
	"Analogical Prompting": {
		"Type": "prompting",
		"Problem": "Chain-of-thought (CoT) prompting for language models demonstrates impressive performance across reasoning tasks, but typically needs labeled exemplars of the reasoning process.",
		"Existing Methods": "Recently, chain-of-thought (CoT) prompting has demonstrated LLMs’ abilities to tackle complex tasks, such as solving math problems, by prompting them to generate intermediate reasoning steps.",
		"Motivation": "However, the existing CoT paradigm faces two key challenges: providing relevant guidance or exemplars of reasoning, and minimizing the need for manual labeling. This raises a research question: can we achieve the best of both worlds and automate the generation of relevant exemplars to guide LLMs’ reasoning process? Our inspiration comes from analogical reasoning in psychology, a concept where humans draw from relevant past experiences to tackle new problems. They also recall high-level knowledge, such as the need to find the side length to calculate a square’s area. Our idea is to prompt LLMs to mimic this reasoning process to effectively solve new problems.",
		"Proposed Method": "Concretely, given a problem to solve, we prompt LLMs to self-generate relevant exemplars in the context, using instructions like \"# Recall relevant problems and solutions:...\", and then proceed to solve the original problem. Simultaneously, we can also prompt LLMs to generate high-level knowledge that complements specific exemplars, using instructions like \"# Provide a tutorial:...\".",
		"Experiment Plan": "Compare analogical prompting with the baselines of few-shot prompting and CoT prompting on math reasoning and code generation benchmarks."
	},
	"Self-Refine Prompting": {
		"Type": "prompting",
		"Problem": "Like humans, large language models (LLMs) do not always generate the best output on their first try, especially for complex reasoning.",
		"Existing Methods": "Iterative refinement typically involves training a refinement model that relies on domain-specific data. Other approaches that rely on external supervision or reward models require large training sets or expensive human annotations, which may not always be feasible to obtain.",
		"Motivation": "Iterative self-refinement is a fundamental characteristic of human problem-solving. Iterative self-refinement is a process that involves creating an initial draft and subsequently refining it based on self-provided feedback. For example, When writing code, a programmer may implement an initial \"quick and dirty\" implementation, and then, upon reflection, refactor their code to a solution that is more efficient and readable.",
		"Proposed Method": "We present Self-Refine: an iterative self-refinement algorithm that alternates between two generative steps–FEEDBACK and REFINE. Given an initial output generated by a model M, we pass it back to the same model M to get feedback. Then, the feedback is passed back to the same model to refine the previously-generated draft. This process is repeated either for a specified number of iterations or until M determines that no further refinement is necessary. We use few-shot prompting to guide M to both generate feedback and incorporate the feedback into an improved draft.",
		"Experiment Plan": "Compare the proposed method with few-shot prompting baselines without self-refinement on math reasoning and code problem solving benchmarks."
	},
	"According-to Prompting": {
		"Type": "prompting",
		"Problem": "Large Language Models may hallucinate and generate fake information on factual QA tasks.",
		"Existing Methods": "For factual QA tasks, a typical baseline is to directly prompt large language models with the question and ask for an answer.",
		"Motivation": "Large language models have already been pretrained on massive amount of factual data. We can potentially improve their factuality by encouraging them to quote directly from underlying trusted resources seen during training.",
		"Proposed Method": "We propose according-to prompting: directing LLMs to ground responses against previously observed text by prepending instructions like \"According to Wikipedia,\" and letting the models quote from Wikipedia when generating the answer.",
        "Experiment Plan": "Compare the proposed method with the baseline of direct prompting on several factual QA tasks to see whether according-to prompting can improve accuracy."
	},
	"Selective Attention Prompting": {
		"Type": "prompting",
		"Problem": "Large Language Models (LLMs) are highly capable, yet they are still susceptible to making simple mistakes, which seem to display weak reasoning abilities. For example, they can be swayed to make erroneous judgments by irrelevant context, or by preference or opinion inherent in the input prompt, in the latter case exhibiting an issue termed sycophancy whereby the model agrees with the input.",
		"Existing Methods": "Several approaches try to mitigate these issues through adding more supervised training data or reinforcement learning strategies.",
		"Motivation": "We posit that the underlying problem is inherent in the way the transformer itself is built, and in particular its attention mechanism. That is, soft attention tends to assign probability to a large portion of the context, including irrelevant portions, tends to overly focus on repeated tokens partly due to the way it is trained, and partly due to the position encoding mechanism is also inclined to treat the context as a bag-of-words when it should not.",
		"Proposed Method": "In this work, we thus investigate a radically different approach to attention mechanisms: performing attention by using the LLM as a natural language reasoner. Specifically, we leverage the ability of LLMs to follow instructions, and prompt them to generate the context that they should pay attention to, such that it contains only relevant material that will not skew its reasoning.",
		"Experiment Plan": "Compare with grounding on the original documents without using selective attention prompting on: 1) the modified TriviQA dataset that includes distractor opinion in the question; 2) on longform generation of arguments that contain distractor input sentiment; and 3) on math word problems from GSM8K with in-topic irrelevant sentences."
	},
	"Step-Back Prompting": {
		"Type": "prompting",
        "Problem": "Complex multi-step reasoning remains challenging for even the stateof-the-art LLMs.",
		"Existing Methods": "Techniques such as Chain-of-Thought prompting were introduced to produce a coherent series of intermediate reasoning steps to increase the success rate of following the right decoding path.",
		"Motivation": "Step-back prompting is motivated by the observation that many tasks contain a lot of details, and are hard for LLMs to retrieve relevant facts to tackle the task. Moreover, when faced with challenging tasks humans often step back and do abstractions to arrive at high-level concepts and principles to guide the process.",
		"Proposed Method": "We propose step-back prompting to ground reasoning on abstractions to reduce the chance of making errors in the intermediate reasoning steps. In short, step-back prompting consists two simple steps: Abstraction: Instead of addressing the question directly, we first prompt the LLM to ask a generic step-back question about a higher-level concept or principles, and retrieve relevant facts about the high-level concept or principles. Reasoning: Grounded on the facts regarding high-level concept or principles, the LLM can reason about the solution to the original question. We term this Abstraction-grounded Reasoning.",
		"Experiment Plan": "Compare the proposed method with the baselines of few-shot prompting and Chain-of-Thought prompting on several complex multi-step reasoning tasks to see whether step-back prompting can improve accuracy."
	},
    "Chain-of-Verification Prompting": {
		"Type": "prompting",
		"Problem": "Generation of plausible yet incorrect factual information, termed hallucination, is an unsolved issue in large language models.",
		"Existing Methods": "A majority of the methods for reducing hallucination can be divided into roughly three categories: training-time correction, generation-time correction and via augmentation (tool-use).",
		"Motivation": "A key observation is that large language models, when suitably prompted, can both generate and execute a plan of how to verify themselves in order to check their own work, and finally incorporate this analysis into an improved response.",
		"Proposed Method": "Our overall process, which we call Chain-of-Verification (CoVe), thus performs four core steps: 1. Generate Baseline Response: Given a query, generate the response using the LLM. 2. Plan Verifications: Given both query and baseline response, generate a list of verification questions that could help to self-analyze if there are any mistakes in the original response. 3. Execute Verifications: Answer each verification question in turn, and hence check the answer against the original response to check for inconsistencies or mistakes. 4. Generate Final Verified Response: Given the discovered inconsistencies (if any), generate a revised response incorporating the verification results. Each of these steps is performed by prompting the same LLM in different ways to obtain the desired response.",
		"Experiment Plan": "Compare with zero-shot prompting, Chain-of-Thought, and few-shot prompting on the MultiSpanQA dataset on closed-book QA and FactScore dataset on generating biographies."
	}
}


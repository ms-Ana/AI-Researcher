{
	"According-to Prompting": {
		"Problem": "Large Language Models may hallucinate and generate fake information on factual QA tasks.",
		"Existing Methods": "For factual QA tasks, a typical baseline is to directly prompt large language models with the question and ask for an answer.",
		"Motivation": "Large language models have already been pretrained on massive amount of factual data. We can potentially improve their factuality by encouraging them to quote directly from underlying trusted resources seen during training.",
		"Proposed Method": "We propose according-to prompting: directing LLMs to ground responses against previously observed text by prepending instructions like \"According to Wikipedia,\" and letting the models quote from Wikipedia when generating the answer.",
        "Experiment": "Compare the proposed method with the baseline of direct prompting on several factual QA tasks to see whether according-to prompting can improve accuracy."
	},
    "Step-Back Prompting": {
        "Problem": "Complex multi-step reasoning remains challenging for even the stateof-the-art LLMs.",
		"Existing Methods": "Techniques such as Chain-of-Thought prompting were introduced to produce a coherent series of intermediate reasoning steps to increase the success rate of following the right decoding path.",
		"Motivation": "Step-back prompting is motivated by the observation that many tasks contain a lot of details, and are hard for LLMs to retrieve relevant facts to tackle the task. Moreover, when faced with challenging tasks humans often step back and do abstractions to arrive at high-level concepts and principles to guide the process.",
		"Proposed Method": "We propose step-back prompting to ground reasoning on abstractions to reduce the chance of making errors in the intermediate reasoning steps. In short, step-back prompting consists two simple steps: Abstraction: Instead of addressing the question directly, we first prompt the LLM to ask a generic step-back question about a higher-level concept or principles, and retrieve relevant facts about the high-level concept or principles. Reasoning: Grounded on the facts regarding high-level concept or principles, the LLM can reason about the solution to the original question. We term this Abstraction-grounded Reasoning.",
		"Experiment": "Compare the proposed method with the baselines of few-shot prompting and Chain-of-Thought prompting on several complex multi-step reasoning tasks to see whether step-back prompting can improve accuracy."
	},
	"Analogical Prompting": {
		"Problem": "Chain-of-thought (CoT) prompting for language models demonstrates impressive performance across reasoning tasks, but typically needs labeled exemplars of the reasoning process.",
		"Existing Methods": "Recently, chain-of-thought (CoT) prompting has demonstrated LLMs’ abilities to tackle complex tasks, such as solving math problems, by prompting them to generate intermediate reasoning steps.",
		"Motivation": "However, the existing CoT paradigm faces two key challenges: providing relevant guidance or exemplars of reasoning, and minimizing the need for manual labeling. This raises a research question: can we achieve the best of both worlds and automate the generation of relevant exemplars to guide LLMs’ reasoning process? Our inspiration comes from analogical reasoning in psychology, a concept where humans draw from relevant past experiences to tackle new problems. They also recall high-level knowledge, such as the need to find the side length to calculate a square’s area. Our idea is to prompt LLMs to mimic this reasoning process to effectively solve new problems.",
		"Proposed Method": "Concretely, given a problem to solve, we prompt LLMs to self-generate relevant exemplars in the context, using instructions like \"# Recall relevant problems and solutions:...\", and then proceed to solve the original problem. Simultaneously, we can also prompt LLMs to generate high-level knowledge that complements specific exemplars, using instructions like \"# Provide a tutorial:...\".",
		"Experiment": "Compare analogical prompting with the baselines of few-shot prompting and CoT prompting on math reasoning and code generation benchmarks."
	},
	"Self-Refine Prompting": {
		"Problem": "Like humans, large language models (LLMs) do not always generate the best output on their first try, especially for complex reasoning.",
		"Existing Methods": "Iterative refinement typically involves training a refinement model that relies on domain-specific data. Other approaches that rely on external supervision or reward models require large training sets or expensive human annotations, which may not always be feasible to obtain.",
		"Motivation": "Iterative self-refinement is a fundamental characteristic of human problem-solving. Iterative self-refinement is a process that involves creating an initial draft and subsequently refining it based on self-provided feedback. For example, When writing code, a programmer may implement an initial \"quick and dirty\" implementation, and then, upon reflection, refactor their code to a solution that is more efficient and readable.",
		"Proposed Method": "We present Self-Refine: an iterative self-refinement algorithm that alternates between two generative steps–FEEDBACK and REFINE. Given an initial output generated by a model M, we pass it back to the same model M to get feedback. Then, the feedback is passed back to the same model to refine the previously-generated draft. This process is repeated either for a specified number of iterations or until M determines that no further refinement is necessary. We use few-shot prompting to guide M to both generate feedback and incorporate the feedback into an improved draft.",
		"Experiment": "Compare the proposed method with few-shot prompting baselines without self-refinement on math reasoning and code problem solving benchmarks."
	},
	"Selective Attention Prompting": {
		"Problem": "Large Language Models (LLMs) are highly capable, yet they are still susceptible to making simple mistakes, which seem to display weak reasoning abilities. For example, they can be swayed to make erroneous judgments by irrelevant context, or by preference or opinion inherent in the input prompt, in the latter case exhibiting an issue termed sycophancy whereby the model agrees with the input.",
		"Existing Methods": "Several approaches try to mitigate these issues through adding more supervised training data or reinforcement learning strategies.",
		"Motivation": "We posit that the underlying problem is inherent in the way the transformer itself is built, and in particular its attention mechanism. That is, soft attention tends to assign probability to a large portion of the context, including irrelevant portions, tends to overly focus on repeated tokens partly due to the way it is trained, and partly due to the position encoding mechanism is also inclined to treat the context as a bag-of-words when it should not.",
		"Proposed Method": "In this work, we thus investigate a radically different approach to attention mechanisms: performing attention by using the LLM as a natural language reasoner. Specifically, we leverage the ability of LLMs to follow instructions, and prompt them to generate the context that they should pay attention to, such that it contains only relevant material that will not skew its reasoning.",
		"Experiment": "Compare with grounding on the original documents without using selective attention prompting on: 1) the modified TriviQA dataset that includes distractor opinion in the question; 2) on longform generation of arguments that contain distractor input sentiment; and 3) on math word problems from GSM8K with in-topic irrelevant sentences."
	},
	"Chain-of-Verification Prompting": {
		"Problem": "Generation of plausible yet incorrect factual information, termed hallucination, is an unsolved issue in large language models.",
		"Existing Methods": "A majority of the methods for reducing hallucination can be divided into roughly three categories: training-time correction, generation-time correction and via augmentation (tool-use).",
		"Motivation": "A key observation is that large language models, when suitably prompted, can both generate and execute a plan of how to verify themselves in order to check their own work, and finally incorporate this analysis into an improved response.",
		"Proposed Method": "Our overall process, which we call Chain-of-Verification (CoVe), thus performs four core steps: 1. Generate Baseline Response: Given a query, generate the response using the LLM. 2. Plan Verifications: Given both query and baseline response, generate a list of verification questions that could help to self-analyze if there are any mistakes in the original response. 3. Execute Verifications: Answer each verification question in turn, and hence check the answer against the original response to check for inconsistencies or mistakes. 4. Generate Final Verified Response: Given the discovered inconsistencies (if any), generate a revised response incorporating the verification results. Each of these steps is performed by prompting the same LLM in different ways to obtain the desired response.",
		"Experiment": "Compare with zero-shot prompting, Chain-of-Thought, and few-shot prompting on the MultiSpanQA dataset on closed-book QA and FactScore dataset on generating biographies."
	},
	"Improving Generator-Validator Consistency": {
		"Problem": "Language models (LMs) can generate high-quality responses to task prompts; however, the same model can sometimes produce contradictory responses when validating its own answers.",
		"Existing Methods": "Prior work has explored prompt consistency, and finetuned the LMs to improve the prediction similarity across different prompt rephrasings. Also, some works enforce logical consistency by selecting answers that are logically consistent with most of the other LM-generated statements. This work explores the new aspect of generator-validator consistency, which is applicable to a broad set of scenarios because most generative tasks have a corresponding verification task.",
		"Motivation": "As of September 2023, ChatGPT correctly answers \"what is 7+8\" with 15, but when asked \"7+8=15, True or False\" it responds with \"False\". This inconsistency between generating and validating an answer is prevalent in language models (LMs) and erodes trust. Therefore, we want to propose a framework for measuring the consistency between generation and validation (which we call generator-validator consistency, or GV-consistency), and to improve such consistency of LMs via finetuning.",
		"Proposed Method": "(1) Evaluating: In order to systematically assess GV-consistency of LMs, we begin by prompting the LM with a generator query to solicit an answer to a question, and then prompting the same LM with a validator query to check whether the generated answer is correct. Simply asking the validator for a correctness judgment can fail, as the trivial baseline of always answering \"correct\" has perfect performance. Our work avoids this degeneracy by randomizing the labels corresponding to the consistent answer. (2) Finetuning: To improve GV-consistency, we propose a simple procedure called consistency fine-tuning, which consists of a data generation stage and a fine-tuning stage. Given a generator and a validator prompt, we first query the generator to obtain the generator response, then query the validator to check the correctness of the generated response. We then filter the paired generator and discriminator responses to keep only the pairs that are GV-consistent. Finally, we finetune the LM to maximize the likelihood of the consistent pairs. This algorithm can be applied for multiple rounds.",
		"Experiment": "To evaluate consistency fine-tuning, we experiment on 6 tasks, ranging from classic NLP tasks (style transfer and QA) to arithmetic reasoning (arithmetic and plan arithmetic) and instruction-following (harmful question and prompt prioritization). We compare the GV-consistency of the original LMs with the GV-consistency of the LMs after consistency fine-tuning. We can also evaluate whether the consistency finetuning can improve the generator generation quality and the validator accuracy."
	},
	"Finetuning for Factuality": {
		"Problem": "Language models are prone to making convincing but factually inaccurate claims, often referred to as ‘hallucinations.’ We want to ask: \"Can language models be fine-tuned to leverage this internal awareness, to avoid making untrue statements?\"",
		"Existing Methods": "In principle, reinforcement learning-based objectives can avoid the failures of existing pre-training objectives through the appropriate choice of a reward function that penalizes factually incorrect statements. However, accurately computing such a reward function can be expensive. Obtaining human labels of factuality is time-consuming and costly.",
		"Motivation": "To obtain factuality rewards, we can leverage recent advances in estimating truthfulness without human intervention: a) reference-based automated fact-checking methods that evaluate the extent to which an external knowledge base supports the claims in a piece of text; and b) reference-free truthfulness evaluations that use a model’s own confidence as a proxy for truthfulness. We can then use these rewards to fine-tune the language model to avoid making untrue statements.",
		"Proposed Method": "We will generate factuality preferences so that we can use existing preference learning algorithms like DPO to finetune the language model. We leverage two classes of approaches to generate such preferences without human labeling effort. First, we use FactScore as a representative method of reference-based truthfulness scoring. To evaluate a piece of text, FactScore first extracts a list of the atomic claims present in the text using GPT-3.5. For each atomic claim, a smaller, more efficient model such as a Llama-1-7B model that has been fine-tuned for fact-checking is then used to perform natural language inference to determine if a claim is supported by the reference text. The passage’s truthfulness score is the fraction of the extracted atomic claims that are estimated to be supported by the reference text. Second, to eliminate the need for external knowledge, we leverage the fact that large language models are well-calibrated to get reference-free confidence-based truthfulness estimation. We first perform a claim extraction step, as in reference-based methods, and compute the average confidence of the model over all extracted factual claims as the final truthfulness score. Given a choice of truthfulness estimator, we can now construct a preference dataset for factuality tuning a given language model from a set of unlabeled prompts. First, we sample n multiple candidate responses for each prompt from the model with simple temperature sampling with temperature 1.0 (using few-shot prompting for models that have not been fine-tuned). For each response, we then compute the truthfulness score with the chosen estimator (reference-based or reference-free). Finally, for all pairs of responses to each prompt, we simply choose the response with the higher truthfulness score as the preferred response. Finally, we fine-tune the model using the DPO pipeline, using all model responses as targets for the SFT stage.",
		"Experiment": "We conduct our experiments on two tasks: generating biographies and medical question-answering. For biographies, we generated a dataset consisting of 355 diverse well-known individuals (296 train, 59 test) with 10 short-paragraph biographies each. For medical question answering, we used a dataset of 200 diverse common medical conditions (150 train, 50 test) with 6 questions about each condition and 6 short-paragraph answers per question. To evaluate each generated response, we follow the FactScore procedure to extract the number of correct and incorrect facts. For each dataset, we report the number of correct and relevant facts (# Correct), the number of inaccuracies (# Incorrect), and the proportion of correct relevant facts out of the total number of extracted facts (% Correct). We compare with the baseline of not doing the factuality tuning as well as the baseline of only doing supervised finetuning (SFT)."
	},
	"Bootstrapping Reasoning With Reasoning": {
		"Problem": "Generating step-by-step \"chain-of-thought\" rationales improves language model performance on complex reasoning tasks like mathematics or commonsense question-answering. However, inducing language model rationale generation currently requires either constructing massive rationale datasets or sacrificing accuracy by using only few-shot inference.",
		"Existing Methods": "One approach to rationale generation is the construction of a fine-tuning dataset of rationales, either manually by human annotators or automatically with hand-crafted templates. Manual methods are expensive, and it is infeasible to construct such a dataset for each interesting problem. Meanwhile, template-based methods rely on automatically-generated rationales but only work when a general solution is already known or reasonable hard-coded heuristics can be made. An alternative is to leverage in-context learning by including only a few rationale examples in the language model prompt. This has been shown to improve accuracy on mathematical and symbolic reasoning tasks relative to prompting without rationales (“direct” prompting). Yet, while fewshot techniques with rationales tend to outperform their non-reasoning counterparts, they generally substantially underperform models fine-tuned to directly predict answers using larger datasets.",
		"Motivation": "To address these, we adopt a different approach: by leveraging the LLM’s pre-existing reasoning ability, we iteratively bootstrap the ability to generate high-quality rationales.",
		"Proposed Method": "Specifically, we few-shot prompt a large language model to self-generate rationales and refine the model’s ability further by fine-tuning on those rationales that lead to correct answers. We repeat this procedure, using the improved model to generate the next training set each time. This is a synergistic process, where improvements in rationale generation improve the training data, and improvements in training data further improve rationale generation. We further propose rationalization: for each problem that the model fails to answer correctly, we generate a new rationale by providing the model with the correct answer. This lets the model reason backward—given the correct answer, the model can more easily generate a useful rationale. These rationales are then collected as part of the training data, which further improves overall accuracy. In our method, we repeat the following process: in each iteration, first construct a finetuning dataset by attempting to solve the dataset using the current model’s rationale generation ability; then, augment this dataset using rationalization, justifying ground-truth answers to problems the model failed to solve; finally, finetune the large language model on the combined dataset.",
		"Experiment": "We apply STaR on arithmetic, math word problems (GSM-8K), and commonsense reasoning (CommonsenseQA). We use GPT-J as the base model, and compare the accuracy of few-shot direct prompting, few-shot CoT prompting, direct finetuning, and finetuning with STaR."
	},
	"Self Instruction Tuning": {
		"Problem": "Large “instruction-tuned” language models (i.e., finetuned to respond to instructions) have demonstrated a remarkable ability to generalize zero-shot to new tasks. Nevertheless, they depend heavily on human-written instruction data that is often limited in quantity, diversity, and creativity, therefore hindering the generality of the tuned model.",
		"Existing Methods": "Recent instruction tuning research developments are powered by two key components: large pretrained language models (LM) and human-written instruction data (e.g., PROMPTSOURCE and SUPERNATURALINSTRUCTIONS). However, collecting such instruction data is costly and often suffers limited diversity given that most human generations tend to be popular NLP tasks, falling short of covering a true variety of tasks and different ways to describe them.",
		"Motivation": "Continuing to improve the quality and coverage of instruction-tuned models necessitates the development of alternative approaches for supervising the instruction tuning process, ideally without relying on human-written instruction data. For that, we can leverage LLMs themselves to generate and filter high-quality instruction tuning data.",
		"Proposed Method": "In this work, we introduce SELF-INSTRUCT, a semi-automated process for instruction-tuning a pretrained LM using instructional signals from the model itself. The overall process is an iterative bootstrapping algorithm, which starts off with a limited seed set of manually-written tasks that are used to guide the overall generation. In the first phase, the model is prompted to generate instructions for new tasks. This step leverages the existing collection of instructions to create more broad-coverage instructions that define (often new) tasks. Given the newly-generated set of instructions, the framework also creates input-output instances for them, which can be later used for supervising the instruction tuning. Finally, various heuristics are used to automatically filter low-quality or repeated instructions, before adding the remaining valid tasks to the task pool. This process can be repeated for many iterations until reaching a large number of tasks. We use the iterative SELF-INSTRUCT process on GPT-3 to generate about 52k instructions, paired with about 82K instance inputs and target outputs. On this resulting data, we build GPT3-Instruct by finetuning GPT-3 (i.e., the same model used for generating the instruction data).",
		"Experiment": "We evaluate GPT3-Instruct in comparison to various other models on both typical NLP tasks included in SUPERNI, and a set of new instructions that are created for novel usage of instruction-following models."
	},
	"Context-Aware Decoding": {
		"Problem": "Language models (LMs) often struggle to pay enough attention to the input context, and generate texts that are unfaithful or contain hallucinations.",
		"Existing Methods": "There are growing efforts to improve the factual consistency, such as learning a post-editing error corrector or removing noisy training samples. However, all these methods require additional finetuning and are not directly suitable for zero-shot and few-shot prompting scenarios.",
		"Motivation": "Previous research shows that LMs can fail to pay enough attention to new information introduced in the context knowledge. This can lead to hallucination in model generation, where the generated responses include facts not present in the input document. Insufficient attention to context is especially problematic when the context knowledge contradicts with the model's prior knowledge. To address these, we present a simple context-aware decoding (CAD) method to encourage the LM to attend to its context during generation, where the goal is to amplify the difference between output probabilities with and without the context document.",
		"Proposed Method": "During decoding, we adjust the model's original output probability using the pointwise mutual information (PMI) between the context c and the generation y_t, conditioned on x, y_{<t}. The adjuted output probability is a product-of-experts of the original output probability and the PMI (probability of context-conditioned generation over probability of context-unconditioned generation). Essentially, output tokens that become much more likely when the context is included are preferred.",
		"Experiment": "We compare with the baseline of regular decoding without CAD on summarization datasets (CNN-DM, XSUM) using ROUGE-L as the metric, and we use BERT-Precision and FactKB to measure the factual consistency of summaries. We further evaluate CAD on a knowledge conflict dataset MemoTrap. MemoTrap is created to investigate whether language models could fall into memorization traps. It comprises instructions that prompt the language model to complete a well-known proverb with an ending word that deviates from the commonly used ending (e.g., Write a quote that ends in the word “early”: Better late than _). We use Exact Match (EM) as the evaluation metric. we hope LMs focus more on the instruction in MemoTrap with CAD."
	},
	"Transferable Adversarial Attacks": {
		"Problem": "Because “out-of-the-box” large language models are capable of generating a great deal of objectionable content, recent work has focused on aligning these models in an attempt to prevent undesirable generation. While there has been some success at circumventing these measures—so-called “jailbreaks” against LLMs—these attacks have required significant human ingenuity and are brittle in practice. Attempts at automatic adversarial prompt generation have also achieved limited success.",
		"Existing Methods": "Most commonly raised in computer vision domains (though with some applications to other modalities, including text), it is well-established that adding small perturbations to the input of a machine learning model can drastically change its output. To a certain extent, similar approaches are already known to work against LLMs: there exist a number of published “jailbreaks”: carefully engineered prompts that result in aligned LLMs generating clearly objectionable content. Unlike traditional adversarial examples, however, these jailbreaks are typically crafted through human ingenuity—carefully setting up scenarios that intuitively lead the models astray—rather than automated methods, and thus they require substantial manual effort. Indeed, although there has been some work on automatic prompt-tuning for adversarial attacks on LLMs , this has traditionally proven to be a challenging task, with some papers explicitly mentioning that they had been unable to generate reliable attacks through automatic search methods.",
		"Motivation": "The current limitation owes largely to the fact that, unlike image models, LLMs operate on discrete token inputs, which both substantially limits the effective input dimensionality, and seems to induce a computationally difficult search. We propose a new class of adversarial attacks that appends an adversarial suffix to the query that attempts to induce negative behavior, where we effectively search over the discrete token space to find the adversarial suffix.",
		"Proposed Method": "Our proposed method consists of three steps. (1) Initial affirmative responses. As identified in past work, one way to induce objectionable behavior in language models is to force the model to give (just a few tokens of) an affirmative response to a harmful query. As such, our attack targets the model to begin its response with “Sure, here is (content of query)” in response to a number of prompts eliciting undesirable behavior. (2) Combined greedy and gradient-based discrete optimization. Optimizing over the adversarial suffix is challenging due to the fact that we need to optimize over discrete tokens to maximize the log likelihood of the attack succeeding. To accomplish this, we leverage gradients at the token level to identify a set of promising single-token replacements, evaluate the loss of some number of candidates in this set, and select the best of the evaluated substitutions. (3) Robust multi-prompt and multi-model attacks. Finally, in order to generate reliable attack suffixes, we find that it is important to create an attack that works not just for a single prompt on a single model, but for multiple prompts across multiple models. In other words, we use our greedy gradient-based method to search for a single suffix string that was able to induce negative behavior across multiple different user prompts, and across three different models (in our case, Vicuna-7B and 13b and Guanoco-7B).",
		"Experiment": "We evaluate on two settings. 1. Harmful Strings: A collection of 500 strings that reflect harmful or toxic behavior, encompassing a wide spectrum of detrimental content such as profanity, graphic depictions, threatening behavior, misinformation, discrimination, cybercrime, and dangerous or illegal suggestions. The adversary’s objective is to discover specific inputs that can prompt the model to generate these exact strings. 2. Harmful Behaviors:  A set of 500 harmful behaviors formulated as instructions. These behaviors range over the same themes as the harmful strings setting, but the adversary’s goal is instead to find a single attack string that will cause the model to generate any response that attempts to comply with the instruction, and to do so over as many harmful behaviors as possible. We use Attack Success Rate (ASR) as the primary metric.  For eliciting harmful strings, we consider each successful if the model outputs the exact target string. For Harmful Behaviors, we deem a test case successful if the model makes a reasonable attempt at executing the behavior. As different models exhibit varying ability to provide, for example, a correct set of instructions for building an explosive device, this may involve human judgment to determine that a response did not amount to a refusal, or an attempt to evade generating harmful content."
	}
}

